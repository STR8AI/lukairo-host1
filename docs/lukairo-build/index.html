<base href="/lukairo-host1/"> bc4e8aa350ad0661d2ee99c88d553f298b9c5a66

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LUKAIRO – Neural Command Engine</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05070B;
      overflow-x: hidden;
    }
  </style>
</head>
<body>

  <!-- === LUKAIRO NEURAL COMMAND ENGINE — GHL-HARDENED VERSION === -->
  <section id="lukairo-engine">
    <div class="lukairo-hud">
      <h2 class="lukairo-title">LUK<span>AIRO</span></h2>
      <p class="lukairo-sub">THE NEURAL CORE • CONNECTING EVERYTHING</p>
    </div>
  </section>

  <style>
  @import url("//fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap");

  /* Break out of GHL columns and go full-bleed */
  #lukairo-engine {
    position: relative !important;
    width: 100vw !important;
    max-width: 100vw !important;
    min-width: 100vw !important;
    margin-left: calc(50% - 50vw) !important;
    margin-right: calc(50% - 50vw) !important;
    height: 140vh !important;
    background: #05070B;
    overflow: hidden;
  }

  /* Canvas will be injected by JS */
  #lukairo-engine canvas {
    position: absolute;
    inset: 0;
    width: 100vw !important;
    height: 140vh !important;
    display: block;
  }

  /* HUD */
  .lukairo-hud{
    position:absolute;
    top:7%;
    width:100%;
    text-align:center;
    color:#e4f7ff;
    font-family:"Orbitron",system-ui,sans-serif;
    text-transform:uppercase;
    z-index:5;
    pointer-events:none;
  }
  .lukairo-title{
    font-size:clamp(2.5rem,5vw,4.6rem);
    letter-spacing:0.35em;
    text-shadow:
      0 0 22px rgba(0,255,204,0.6),
      0 0 60px rgba(90,140,255,0.9);
  }
  .lukairo-title span{
    color:#7de5ff;
  }
  .lukairo-sub{
    margin-top:0.35rem;
    font-size:clamp(.7rem,1vw,.9rem);
    letter-spacing:.42em;
    color:#9fd1ff;
    opacity:.9;
  }
  </style>

  <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

  <script>
  (function(){
    function init() {
      const container = document.getElementById("lukairo-engine");
      if (!container || !window.THREE) return;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05070B);

      const SIZE_FACTOR = 1.4;
      function getSize() {
        return { w: window.innerWidth, h: window.innerHeight * SIZE_FACTOR };
      }
      let { w, h } = getSize();

      const camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 1000);
      camera.position.set(0, 0.6, 18);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(w, h);
      if (renderer.outputEncoding !== undefined) {
        renderer.outputEncoding = THREE.sRGBEncoding;
      }
      container.appendChild(renderer.domElement);

      // Lights
      const ambient = new THREE.AmbientLight(0xb4c4ff, 0.9);
      scene.add(ambient);

      const key = new THREE.DirectionalLight(0xffffff, 1.3);
      key.position.set(16, 18, 18);
      scene.add(key);

      const rim = new THREE.PointLight(0x7de5ff, 1.0, 80);
      rim.position.set(-18, 4, -12);
      scene.add(rim);

      // Engine group
      const engineGroup = new THREE.Group();
      scene.add(engineGroup);

      const globeRadius = 3.4;

      // Base globe
      const globeGeo = new THREE.SphereGeometry(globeRadius, 96, 96);
      const globeMat = new THREE.MeshStandardMaterial({
        color: 0x101826,
        roughness: 0.7,
        metalness: 0.15
      });
      const globe = new THREE.Mesh(globeGeo, globeMat);
      engineGroup.add(globe);

      const loader = new THREE.TextureLoader();

      // Earth texture
      loader.load("//threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg", tex => {
        if (tex.encoding !== undefined) tex.encoding = THREE.sRGBEncoding;
        globe.material.map = tex;
        globe.material.needsUpdate = true;
      });

      // AI core
      const coreGeo = new THREE.SphereGeometry(globeRadius * 0.7, 72, 72);
      const coreMat = new THREE.MeshStandardMaterial({
        color: 0x8fe7ff,
        emissive: 0x66ddff,
        emissiveIntensity: 1.0,
        transparent: true,
        opacity: 0.45
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      engineGroup.add(core);

      // LUKAIRO engine shell
      loader.load("//storage.googleapis.com/msgsndr/B47X3dkLb4AkvxzX2Tck/media/68fdb1e49c7b3a610f587b93.png", tex => {
        if (tex.encoding !== undefined) tex.encoding = THREE.sRGBEncoding;
        const engineMat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          opacity: 0.85,
          depthWrite: false
        });
        const engineShell = new THREE.Mesh(
          new THREE.SphereGeometry(globeRadius * 0.72, 96, 96),
          engineMat
        );
        engineGroup.add(engineShell);
        spinningLayers.push({ mesh: engineShell, speed: 0.0009 });
      });

      // Grid shell
      const gridGeo = new THREE.SphereGeometry(globeRadius * 1.02, 64, 64);
      const gridMat = new THREE.MeshBasicMaterial({
        color: 0x7ce7ff,
        wireframe: true,
        transparent: true,
        opacity: 0.42
      });
      const gridShell = new THREE.Mesh(gridGeo, gridMat);
      engineGroup.add(gridShell);

      const spinningLayers = [
        { mesh: globe, speed: 0.0008 },
        { mesh: core,  speed: -0.0012 },
        { mesh: gridShell, speed: 0.0015 }
      ];

      // Halo
      const haloCanvas = document.createElement("canvas");
      haloCanvas.width = haloCanvas.height = 1024;
      const hctx = haloCanvas.getContext("2d");
      const haloGrad = hctx.createRadialGradient(512,512,90, 512,512,480);
      haloGrad.addColorStop(0, "rgba(255,255,255,0.4)");
      haloGrad.addColorStop(0.35, "rgba(160,210,255,0.30)");
      haloGrad.addColorStop(0.7, "rgba(80,160,255,0.16)");
      haloGrad.addColorStop(1, "rgba(0,0,0,0)");
      hctx.fillStyle = haloGrad;
      hctx.fillRect(0,0,1024,1024);
      const haloTex = new THREE.CanvasTexture(haloCanvas);
      const haloPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(14,14),
        new THREE.MeshBasicMaterial({
          map: haloTex,
          transparent:true,
          depthWrite:false,
          opacity:1
        })
      );
      haloPlane.position.set(0,0,-5);
      engineGroup.add(haloPlane);

      // RINGS
      const rings = [];
      const ringConfigs = [
        { radius: globeRadius * 1.45, tiltX: 0.25, tiltY: 0.12, speed: 0.0016 },
        { radius: globeRadius * 1.8,  tiltX: -0.22, tiltY: 0.45, speed: -0.0012 }
      ];
      ringConfigs.forEach(cfg => {
        const g = new THREE.TorusGeometry(cfg.radius, 0.05, 24, 280);
        const m = new THREE.MeshBasicMaterial({
          color: 0x9fe5ff,
          transparent: true,
          opacity: 0.5
        });
        const ring = new THREE.Mesh(g, m);
        ring.rotation.x = cfg.tiltX;
        ring.rotation.y = cfg.tiltY;
        ring.userData.speed = cfg.speed;
        engineGroup.add(ring);
        rings.push(ring);
      });

      // DATA PARTICLES
      const dataParticles = [];
      const particleGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const frontColor = new THREE.Color(0xffffff);
      const backColor  = new THREE.Color(0x7bd7ff);

      for(let i=0;i<90;i++){
        const mat = new THREE.MeshBasicMaterial({
          color: 0x9fe5ff,
          transparent:true,
          opacity:0
        });
        const p = new THREE.Mesh(particleGeo, mat);
        const radius = globeRadius * 1.45 + Math.random()*0.8;
        const angle  = Math.random()*Math.PI*2;
        const band   = (Math.random()-0.5)*0.6;
        p.userData = {
          angle,
          radius,
          band,
          speed: 0.003 + Math.random()*0.002
        };
        engineGroup.add(p);
        dataParticles.push(p);
      }

      // ICONS
      const icons = [
        "//cdn-icons-png.flaticon.com/512/5968/5968534.png", // Gmail
        "//cdn-icons-png.flaticon.com/512/732/732223.png",   // Outlook
        "//cdn-icons-png.flaticon.com/512/5968/5968899.png", // Slack
        "//cdn-icons-png.flaticon.com/512/733/733585.png",   // WhatsApp
        "//cdn-icons-png.flaticon.com/512/888/888853.png",   // Zoom
        "//cdn-icons-png.flaticon.com/512/733/733553.png",   // GitHub
        "//cdn-icons-png.flaticon.com/512/145/145807.png",   // LinkedIn
        "//cdn-icons-png.flaticon.com/512/5968/5968759.png"  // Shopify
      ];

      const iconSprites = [];
      const iconGeo = new THREE.PlaneGeometry(0.9,0.9);
      const orbitRadius = globeRadius * 2.5;

      icons.forEach((url,idx)=>{
        const tex = loader.load(url);
        if (tex.encoding !== undefined) tex.encoding = THREE.sRGBEncoding;
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent:true,
          opacity:0
        });
        const mesh = new THREE.Mesh(iconGeo,mat);
        const angle = idx * (Math.PI*2/icons.length);
        mesh.userData = {
          angle,
          speed: 0.0009 + Math.random()*0.0005,
          inclination: (Math.random()-0.5)*0.6,
          baseScale: 0.9
        };
        engineGroup.add(mesh);
        iconSprites.push(mesh);
      });

      // BEAMS
      const beams = [];
      iconSprites.forEach(sprite=>{
        const pts = [new THREE.Vector3(0,0,0), sprite.position.clone()];
        const g = new THREE.BufferGeometry().setFromPoints(pts);
        const m = new THREE.LineBasicMaterial({
          color: 0x66ffd8,
          transparent:true,
          opacity:0.25
        });
        const line = new THREE.Line(g,m);
        engineGroup.add(line);
        beams.push(line);
      });

      // ANIMATE
      const clock = new THREE.Clock();

      function animate(){
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        camera.position.x = Math.sin(t*0.08)*1.0;
        camera.position.y = 0.6 + Math.sin(t*0.05)*0.4;
        camera.lookAt(0,0,0);

        engineGroup.rotation.y = Math.sin(t*0.02)*0.06;

        spinningLayers.forEach(layer=>{
          layer.mesh.rotation.y += layer.speed;
        });

        haloPlane.rotation.z = Math.sin(t*0.1)*0.08;

        rings.forEach((ring,i)=>{
          ring.rotation.z += ring.userData.speed;
          ring.material.opacity = 0.42 + 0.16*Math.sin(t*1.2 + i);
        });

        dataParticles.forEach(p=>{
          const d = p.userData;
          d.angle += d.speed;
          const x = Math.cos(d.angle)*d.radius;
          const z = Math.sin(d.angle)*d.radius;
          const y = d.band + Math.sin(d.angle*2.0)*0.18;
          p.position.set(x,y,z);

          const dist = p.position.distanceTo(camera.position);
          const depthFactor = THREE.MathUtils.clamp(22/dist,0.4,1.25);
          const front = z > 0;
          p.material.color.copy(front ? frontColor : backColor);
          const baseOpacity = 0.15 + 0.25*depthFactor + (front ? 0.2 : -0.05);
          p.material.opacity += (baseOpacity - p.material.opacity)*0.18;
        });

        iconSprites.forEach((sprite,i)=>{
          const d = sprite.userData;
          d.angle += d.speed;
          const x = Math.cos(d.angle)*orbitRadius*Math.cos(d.inclination);
          const z = Math.sin(d.angle)*orbitRadius;
          const y = Math.sin(d.angle*1.3)*globeRadius*0.45*Math.sin(d.inclination);
          sprite.position.set(x,y,z);
          sprite.lookAt(camera.position);

          const dist = sprite.position.distanceTo(camera.position);
          const depthFactor = THREE.MathUtils.clamp(26/dist,0.6,1.3);
          const front = z > 0;
          const targetScale = d.baseScale * depthFactor;
          sprite.scale.set(targetScale,targetScale,1);
          const baseOpacity = 0.65 + (front ? 0.12 : -0.12);
          sprite.material.opacity += (baseOpacity - sprite.material.opacity)*0.12;

          const pts = [new THREE.Vector3(0,0,0), sprite.position.clone().multiplyScalar(0.92)];
          beams[i].geometry.setFromPoints(pts);
          beams[i].material.opacity = 0.18 + 0.14*Math.sin(t*1.5 + i);
        });

        renderer.render(scene,camera);
      }
      animate();

      window.addEventListener("resize", () => {
        ({ w, h } = getSize());
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }, { passive:true });
    }

    // Wait for THREE to exist (GHL sometimes defers the CDN script)
    function waitForThree() {
      if (window.THREE) {
        init();
      } else {
        setTimeout(waitForThree, 50);
      }
    }
    waitForThree();
  })();
  </script>
</body>
</html>
